/*
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        https://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
*/

#ifndef NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_
#define NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_

#include <Common/DataTypes/DataTypeFactory.hpp>
#include <Expressions/ConstantValueExpressionNode.hpp>
#include <Expressions/LogicalExpressions/EqualsExpressionNode.hpp>
#include <Expressions/LogicalExpressions/LessExpressionNode.hpp>
#include <Operators/LogicalOperators/Network/NetworkSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/FileSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/KafkaSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/MQTTSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/NullOutputSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/OPCSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/PrintSinkDescriptor.hpp>
#include <Operators/LogicalOperators/Sinks/ZmqSinkDescriptor.hpp>
#include <Parsers/NebulaPSL/NebulaPSLOperator.hpp>
#include <Parsers/NebulaPSL/NebulaPSLPattern.hpp>
#include <Parsers/NebulaPSL/gen/NesCEPBaseListener.h>
#include <Plans/Query/QueryPlan.hpp>
#include <string>

namespace NES::Parsers {
/**
 * @brief This class creates the query plan from ANTLR AST
 * It inherits from the auto-generated ANTLR base listener to walk the AST created from the pattern string.
 * This enables the parsing of declarative patterns into NES queries.
 */
class NesCEPQueryPlanCreator : public NesCEPBaseListener {
  public:
    /** the following methods read out the AST tree and collect all mined patterns in the global pattern list
     * An example of the AST looks as follows:
     * (query (cepPattern PATTERN test := (compositeEventExpressions (
        (listEvents (eventElem (event A)) (operatorRule AND) (eventElem (event B))) ))
        FROM (inputStreams (inputStream default_logical AS A) , (inputStream default_logical_b AS B))
        WHERE (whereExp (expression (predicate (predicate (expressionAtom (eventAttribute A . (attribute currentSpeed)))) (comparisonOperator <) (predicate (expressionAtom (eventAttribute A . (attribute allowedSpeed)))))))
        WITHIN (timeConstraints [ (interval 3 (intervalType MINUTE)) ])
        INTO (sinkList (sink (sinkType Print) :: testSink))) <EOF>
     * each keyword in the AST has its two functions, enter (when X is visited) and exist (called after all children of X have been visited), contained in the parent class NesCEPBaseListener,
     * auto-generated by the ANTLR dependency (gen-folders)
     */

    //ListEvents
    /** @brief mines pattern from the PATTERN clause
      * @param context
      */
    void enterListEvents(NesCEPParser::ListEventsContext* context) override;

    // EventElement
    /** @brief marks current (event) element as a child of the currentOperatorPointer subPattern and
      * move one step up in the AST hierarchy
      * @param context*/

    void enterEventElem(NesCEPParser::EventElemContext* context) override;

    // Event
    /**
      * @brief marks the position of the event inside of the currentElementPointer subPattern
      * @param context

    void enterEvent(NesCEPParser::EventContext* context) override;*/

    // Operators

    /**
      * @brief leaves the current operator element and changes direction to right to mine right branch for binary operators
      * @param context
      */
    void exitOperatorRule(NesCEPParser::OperatorRuleContext* context) override;

    // FROM clause
    /** @brief substitutes the input stream alias by its real name in every subPattern
      * @param context
      */
    void exitInputStream(NesCEPParser::InputStreamContext* context) override;

    // WHERE clause
    /** @brief marks that the tree walker starts parsing a WHERE clause
      * @param context
      */
    void enterWhereExp(NesCEPParser::WhereExpContext* context) override;

    /** @brief marks that the tree walker finished parsing the WHERE clause
      * @param context
      */
    void exitWhereExp(NesCEPParser::WhereExpContext* context) override;

    //INTO clause
    /**
      * @brief add a sink operator to the sink list
      * @param context
      */
    void enterSink(NesCEPParser::SinkContext* context) override;

    /** @brief append the list of sinks to the query plan
      * @param context
      */
    void exitSinkList(NesCEPParser::SinkListContext* context) override;

    // WITHIN clause
    /** @brief
      * @param context
      */
    void exitInterval(NesCEPParser::IntervalContext* cxt) override;

    /**
      * @brief collects all projection attributes
      * @param context
      */
    void enterOutAttribute(NesCEPParser::OutAttributeContext* context) override;

    /**
      * @brief add the appropriate iteration operator to the OperatorList
      * @param context
      */
    void enterQuantifiers(NesCEPParser::QuantifiersContext* context) override;

    /**
         * @brief extracts WHERE Expressions
         * @param context
         */
    void exitBinaryComparisonPredicate(NesCEPParser::BinaryComparisonPredicateContext* context) override;

    /**
         * @brief extracts Attributes in the WHERE
         * @param context
         */
    void enterAttribute(NesCEPParser::AttributeContext* context) override;

    /**
     * @brief this method creates the query from the NesPattern
     */
    QueryPlanPtr createQueryFromPatternList() const;

    /**
     * @brief this methods add all filter to the queryPlan
     */
    QueryPlanPtr addFilters(QueryPlanPtr queryPlan) const;

    /**
     * @brief this methods parses the user-specified window information to TimeMeasures
     */
    std::pair<Windowing::TimeMeasure, Windowing::TimeMeasure> transformWindowToTimeMeasurements(std::string timeMeasure,
                                                                                                int32_t timeValue) const;

    /**
     * @brief this methods add all projections to the queryPlan
     */
    QueryPlanPtr addProjections(QueryPlanPtr queryPlan) const;

    /**
     * @brief returns the parsed queryPlan
     */
    QueryPlanPtr getQueryPlan() const;

    /**
     * @brief: this function creates an artificial key for the binary operators AND and SEQ
     * @return the unique name of the key
     */
    std::string keyAssignment(std::string keyName) const;

    /**
     * @brief: this function adds a binary operator to the query plan
     * @param operaterName the operator name
     * @param iterator the list of nodes from the ANTLR AST Tree
     */
    QueryPlanPtr addBinaryOperatorToQueryPlan(std::string operaterName,
                                              std::map<int, NebulaPSLOperator>::const_iterator iterator,
                                              QueryPlanPtr queryPlan) const;

    /**
     * @brief: checks if one of the sources for a binary operator is already part of either the left or right queryPlan that are composed by the binary operator, i.e., already added to the final queryPlan
     * @param leftSourceName as string
     * @param rightSourceName as string
     * @return the queryPlan to compose to the final queryPlan
     */
    QueryPlanPtr checkIfSourceIsAlreadyConsumedSource(std::basic_string<char> leftSourceName,
                                                      std::basic_string<char> rightSourceName,
                                                      QueryPlanPtr queryPlan) const;
    /**
     * @brief: Parse the expression node of one side (either left or right) from the ANTLR provided context
     * @param contextValueAsString as string
     * @param currentExpression as string
     * @return the ExpressionNodePtr of the created expression node (ExpressionItem for constant values, Attribute node else)
     */
    ExpressionNodePtr getExpressionItem(std::string contextValueAsString, std::string currentExpression);

  private:
    // pointers to track relationship of AST elements while retrieving pattern specification
    int32_t sourceCounter = 0;
    int32_t lastSeenSourcePtr = -1;

    NebulaPSLPattern pattern;
    int32_t nodeId = 0;
    bool inWhere = false;
    bool leftFilter = true;
    std::string currentLeftExp;
    std::string currentRightExp;
};

}// namespace NES::Parsers

#endif// NES_COORDINATOR_INCLUDE_PARSERS_NEBULAPSL_NEBULAPSLQUERYPLANCREATOR_HPP_
